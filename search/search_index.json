{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"README","text":""},{"location":"#mappr","title":"mappr","text":"<p>Easily convert between arbitrary types.</p>"},{"location":"#goals","title":"Goals","text":"<p>mappr's goal is to make it as easy as possible to define custom converters between arbitrary types in python. It does not concern itself with validation or coercion. It only provides a simple way to define a mapping between two types + some extra functionality to automatically generate converters for simple cases (off by default).</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation<ul> <li>Contribute</li> <li>Reference</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#uv","title":"uv","text":"<pre><code>uv add mappr\n</code></pre>"},{"location":"#pip","title":"pip","text":"<pre><code>pip install mappr\n</code></pre>"},{"location":"#poetry","title":"poetry","text":"<pre><code>poetry add mappr\n</code></pre> <p>If you'd like to setup the project locally for development, see Contribute for more details.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<p>See the Documentation for more examples.</p> <p>Assume we have a following types in our app. They represent pretty much the same thing, but different views of it.</p> <pre><code>    from dataclasses import dataclass\n    import mappr\n\n\n    @dataclass\n    class User:\n        username: str\n        first_name: str\n        last_name: str\n        email: str\n\n\n    class Person:\n        def __init__(self, nick, name, email):\n            self.nick = nick\n            self.name = name\n            self.email = email\n\n\n    # Since we're not using any base class supported out of the box by mappr\n    # we need to define a field_iterator for our Person class. mappr\n    # comes bundled with ones for dataclasses, pydantic (ptional) and\n    # SQLAlchemy (optional). field_iterators are very easy to implement so more\n    # will follow. Of course you can also use field iterators defined by 3rd\n    # party packages. Just needs to be imported prior to converting any objects.\n    @mappr.field_iterator(test=lambda target_cls: isinstance(target_cls, Person))\n    def iter_person(model_cls: Type) -&gt; mappr.FieldIterator:\n        yield from ['nick', 'name', 'email']\n\n    # register User -&gt; Person converter ('email' matches by name so can be skipped)\n    mappr.register(User, Person, mapping=dict(\n        nick=lambda obj, name: obj.username,\n        name=lambda obj, name: f\"{obj.first_name} {obj.last_name}\",\n    ))\n    # register Person -&gt; User converter\n    mappr.register(User, Person, mapping=dict(\n        username=lambda obj, name: obj.nick,\n        first_name=lambda obj, name: obj.name and obj.name.split()[0],\n        last_name=lambda obj, name: obj.name and obj.name.split()[-1],\n    ))\n\n    user = User(\n        username='john.doe',\n        first_name='John',\n        last_name='Doe',\n        email='john.doe@example.com',\n    )\n\n    person = mappr.convert(Person, user)\n    assert person == Person(\n        name='John Doe',\n        email='john.doe@example.com',\n        nick='john.doe',\n    )\n\n    user2 = mappr.Convert(User, person)\n    assert user2 == user\n</code></pre>"},{"location":"pages/contrib/","title":"Contributing","text":""},{"location":"pages/contrib/#setup-up-the-project-for-development","title":"Setup up the project for development","text":"<pre><code>git clone git@github.com:novopl/mappr.git\ncd mappr\nuv sync\n</code></pre>"},{"location":"pages/contrib/#running-tests","title":"Running tests","text":"<pre><code>peltak test\n</code></pre>"},{"location":"pages/contrib/#linting","title":"Linting","text":"<pre><code>peltak check\n</code></pre>"},{"location":"pages/contrib/#generating-docs","title":"Generating docs","text":"<pre><code>peltak docs\n</code></pre>"},{"location":"pages/reference/","title":"API Reference","text":""},{"location":"pages/reference/#convert-an-object-from-one-type-to-anothere","title":"Convert an object from one type to anothere","text":""},{"location":"pages/reference/#mappr.convert","title":"mappr.convert","text":"<pre><code>convert(\n    dst_type: Type[T],\n    src_obj: Any,\n    strict: bool = True,\n    strategy: Optional[Strategy] = None,\n    **extra: Any,\n) -&gt; T\n</code></pre> <p>Convert an object to a given type.</p> PARAMETER DESCRIPTION <code>dst_type</code> <p>Target type. This is the type of the return value.</p> <p> TYPE: <code>Type[T]</code> </p> <code>src_obj</code> <p>An object to convert. A registered converter will be used         to map between the attributes of this object and the target         type.</p> <p> TYPE: <code>Any</code> </p> <code>strict</code> <p>If set to <code>False</code> and the converter is not found for the         given type pair, it will create an ad-hoc one that maps         the attributes by their name. Defaults to <code>True</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>strategy</code> <p>Creation strategy</p> <p> TYPE: <code>Optional[Strategy]</code> DEFAULT: <code>None</code> </p> <code>extra</code> <p>Extra arguments to pass to the converter.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>T</code> <p>A newly created instance of <code>dst_type</code> with values initialized</p> <code>T</code> <p>from <code>src_obj</code>.</p>"},{"location":"pages/reference/#register-new-converter","title":"Register new converter","text":""},{"location":"pages/reference/#mappr.register","title":"mappr.register","text":"<pre><code>register(\n    src_type: Type,\n    dst_type: Type,\n    strategy: Strategy = Strategy.CONSTRUCTOR,\n    mapping: Optional[FieldMapping] = None,\n    strict: bool = True,\n)\n</code></pre> <p>Register new converter.</p> PARAMETER DESCRIPTION <code>src_type</code> <p> TYPE: <code>Type</code> </p> <code>dst_type</code> <p> TYPE: <code>Type</code> </p> <code>strategy</code> <p> TYPE: <code>Strategy</code> DEFAULT: <code>CONSTRUCTOR</code> </p> <code>mapping</code> <p> TYPE: <code>Optional[FieldMapping]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <p>Returns:</p>"},{"location":"pages/reference/#mappr.register_iso","title":"mappr.register_iso","text":"<pre><code>register_iso(\n    src_type: Type,\n    dst_type: Type,\n    strategy: Strategy = Strategy.CONSTRUCTOR,\n    mapping: Optional[Dict[str, str]] = None,\n    strict: bool = True,\n)\n</code></pre>"},{"location":"pages/reference/#mappr.custom_converter","title":"mappr.custom_converter","text":"<pre><code>custom_converter(\n    src_type: Type[T_src],\n    dst_type: Type[T_dst],\n    strategy: Strategy = Strategy.CONSTRUCTOR,\n    strict: bool = True,\n)\n</code></pre> <p>Decorator for registering a custom conversion functions.</p>"},{"location":"pages/reference/#built-in-field-mappers","title":"Built-in field mappers","text":""},{"location":"pages/reference/#mappr.use_default","title":"mappr.use_default","text":"<pre><code>use_default(value: Any, extra: Values) -&gt; Any\n</code></pre> <p>Indicate we want to use default field value  rather than value from source object</p> <p>By default, if the attribute exists on the source object, it's value will be used when creating the result. That happens even if the destination type defines a default value for that field. If you want to use the default provided by the target type you can achive that with <code>mappr.use_default</code> mapper. You simply set the field to <code>mappr.use_default</code> and the attribute value from the source object won't be used (the target default is used). If the target type does not define a default value an exception will be raised during the creation of the final result.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; import mappr\n&gt;&gt;&gt;\n&gt;&gt;&gt; @dataclass\n... class Src:\n...     text: str = 'hello'\n...     num: int = 10\n&gt;&gt;&gt;\n&gt;&gt;&gt; @dataclass\n... class Dst:\n...     text: str\n...     num: int = 20\n&gt;&gt;&gt;\n&gt;&gt;&gt; mappr.register(Src, Dst, mapping=dict(\n...     num=mappr.use_default\n... ))\n&gt;&gt;&gt;\n&gt;&gt;&gt; src = Src()\n&gt;&gt;&gt; dst = mappr.convert(Dst, src)\n&gt;&gt;&gt;\n&gt;&gt;&gt; dst.text\n'hello'\n&gt;&gt;&gt; dst.num\n20\n</code></pre>"},{"location":"pages/reference/#mappr.set_const","title":"mappr.set_const","text":"<pre><code>set_const(value: Any) -&gt; types.MappingFn\n</code></pre> <p>Always set the field to the given value during conversion.</p> <p>You can use <code>mappr.set_const</code> if you want to set an attribute to a constant value during conversion, without concern about the source object. Every call to <code>mappr.convert</code> will return the same value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to set on the field. Instead of using the source     object attribute or target type field default, this value     will be set on the field during conversion.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>MappingFn</code> <p>A mapping function.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; import mappr\n&gt;&gt;&gt;\n&gt;&gt;&gt; @dataclass\n... class Src:\n...     text: str = 'hello'\n...     num: int = 10\n&gt;&gt;&gt;\n&gt;&gt;&gt; @dataclass\n... class Dst:\n...     text: str\n...     num: int = 20\n&gt;&gt;&gt;\n&gt;&gt;&gt; mappr.register(Src, Dst, mapping=dict(\n...     num=mappr.set_const(100)\n... ))\n&gt;&gt;&gt;\n&gt;&gt;&gt; src = Src()\n&gt;&gt;&gt; dst = mappr.convert(Dst, src)\n&gt;&gt;&gt;\n&gt;&gt;&gt; dst.text\n'hello'\n&gt;&gt;&gt; dst.num\n100\n</code></pre>"},{"location":"pages/reference/#mappr.alias","title":"mappr.alias","text":"<pre><code>alias(aliased_name: str) -&gt; types.MappingFn\n</code></pre> <p>The value in the src object has just a different name than in the dst object.</p>"},{"location":"pages/reference/#define-field-iterator-for-a-custom-type","title":"Define field iterator for a custom type","text":""},{"location":"pages/reference/#mappr.field_iterator","title":"mappr.field_iterator","text":"<pre><code>field_iterator(test=types.TestFn)\n</code></pre>"}]}